import compiler.CodeGenerator.ByteArrayClassLoader;
import compiler.CodeGenerator.CodeGenerator;
import compiler.Exceptions.CodeGeneratorException.CodeGeneratorException;
import compiler.Exceptions.LexerException;
import compiler.Exceptions.SemanticException.SemanticException;
import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.text.ParseException;
import java.util.Arrays;

import static org.junit.Assert.assertEquals;

public class TestCodeGenerator {
    private static final boolean VERBOSE = true;
    final PrintStream stdout = System.out;
    private final ByteArrayOutputStream outputStreamCaptor = new ByteArrayOutputStream();

    public Class<?> genClass(String input)
            throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        CodeGenerator cg = new CodeGenerator(TestParser.initParser(input));
        return cg.generateProgram();
    }

    /**
     * Convert a class to the primitive types for int, double and boolean.
     *
     * @param clazz a java class.
     * @return a primitive class or "clazz" if nothing can be done.
     */
    private Class<?> getPrimitiveClass(Class<?> clazz) {
        return switch (clazz.getName()) {
            case "java.lang.Integer" -> int.class;
            case "java.lang.Double", "java.lang.Float" -> double.class;
            case "java.lang.Boolean" -> boolean.class;
            default -> clazz;
        };
    }

    /**
     * Execute a method, using reflection, that's defined inside "clazz" called "name" and with the following arguments.
     *
     * @param clazz bytecode class generated by the compiler that contains "name".
     * @param name  the identifier of the procedure to be called.
     * @param args  the args to pass inside the function call.
     * @return the return value of executing this method.
     */
    public Object callMethod(Class<?> clazz, String name, Object... args) {
        try {
            Class<?>[] argTypes = Arrays.stream(args)
                    .map(Object::getClass)
                    .map(this::getPrimitiveClass)
                    .toArray(Class<?>[]::new);

            return clazz.getMethod(name, argTypes).invoke(null, args);
        } catch (ReflectiveOperationException e) {
            throw new RuntimeException(e);
        }
    }

    public void run(Class<?> clazz, String method, String expected, Object... args) {
        // captures print output by changing stdout
        System.setOut(new PrintStream(outputStreamCaptor));
        callMethod(clazz, method, args);
        String actual = outputStreamCaptor.toString().trim();
        System.setOut(stdout);

        if (VERBOSE)
            System.out.println(actual + "\n --- expected ---\n" + expected);
        assertEquals(expected.replace("\r", ""), actual.replace("\r", ""));
        outputStreamCaptor.reset();
    }

    public void check(String type, String expression, String expected)
            throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        Class<?> clazz = genClass("proc main() void { write" + type + "(" + expression + "); }");

        // captures print output by changing stdout
        System.setOut(new PrintStream(outputStreamCaptor));
        callMethod(clazz, "main");
        String actual = outputStreamCaptor.toString().trim();
        System.setOut(stdout);

        if (VERBOSE)
            System.out.println(expression + " = " + actual + " (" + expected + ")");
        assertEquals(expected, actual);
        outputStreamCaptor.reset();
    }

    public void checkInt(String expression, String expected)
            throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        check("Int", expression, expected);
    }

    public void checkReal(String expression, String expected)
            throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        check("Real", expression, expected);
    }

    public void checkString(String expression, String expected)
            throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        check("", expression, expected);
    }

    public void checkBool(String expression, String expected)
            throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        check("Bool", expression, expected);
    }

    public void checkMethod(Class<?> clazz, String name, Object expected, Object... args) {
        Object actual = callMethod(clazz, name, args);
        if (VERBOSE)
            System.out.println(name + "(" + Arrays.toString(args).replaceAll("[\\[\\]]", "") + ") = " + actual + " ("
                    + expected + ")");
        assertEquals(expected, actual);
    }

    // ======= ======= ======= ======= ======= ======= =======
    // =======                  Tests                  =======
    // ======= ======= ======= ======= ======= ======= =======

    @Test
    public void simpleExpressions() throws ParseException, LexerException, SemanticException, CodeGeneratorException { // TODO wip
        checkInt("5 + 2", "7");

        checkInt("10", "10");
        checkInt("+10", "10");
        checkInt("-10", "-10");
        checkReal(" 10.5", "10.5");
        checkReal("+10.5", "10.5");
        checkReal("-10.5", "-10.5");
        checkString("\"nice\"", "nice");
        checkBool("true", "true");
        checkBool("false", "false");

        checkInt("7 * 2", "14");
        checkReal("7.0 * 2", "14.0");
        checkReal("7 * 2.0", "14.0");
        checkReal("7.2 * 2", "14.4");
        checkReal("7 * 2.7", "18.900000000000002");
        checkReal("7.0 * 2", "14.0");
        checkInt("8 / 2", "4");
        checkInt("7 / 2", "3");
        checkReal("7.0 / 2", "3.5");
        checkReal("7 / 2.0", "3.5");
        checkReal("7.0 / 2.0", "3.5");

        checkString("\"hello\" + \" \" + \"world\" + \"!\"", "hello world!");
        checkString("\"H\" + 2 + \"O\" + \" ... \" + true + \" ... \" + 2.0", "H2O ... true ... 2.0");

        checkInt("7 / 2 + 4 * 2 - 2 * (-2)", "15");
        checkReal("7.0 / 2 + 4 * 2 - 2 * (-2)", "15.5");
        checkInt("8 / (6 + 2 * -2) * 2", "2");

        checkBool("true and false or true", "true"); // true = true and (false or true)
        checkBool("4 > 5", "false");
        checkBool("5 >= 5", "true");
        checkBool("15 >= 5", "true");
        checkBool("4 < 5", "true");

        checkBool("4. < 5", "true");
        checkBool("4. > 5", "false");
        checkBool("4 < 5.", "true");
        checkBool("4 > 5.", "false");
        checkBool("4. < 5.", "true");
        checkBool("4. > 5.", "false");

        checkBool("4 <= 4", "true");
        checkBool("4 == 5", "false");
        checkBool("4 <> 5", "true");
        checkBool("4. > 5", "false");
        checkBool("5 >= 5.", "true");
        checkBool("15. >= 5", "true");
        checkBool("4 < 5.", "true");
        checkBool("4. <= 4", "true");
        checkBool("4 == 5.", "false");
        checkBool("4. <> 5", "true");

        checkBool("5 < 4 or 5 < 4.0 or 5.0 < 4 or 5.0 < 4.0", "false");
        checkBool("5 <= 4 or 5 <= 4.0 or 5.0 <= 4 or 5.0 <= 4.0", "false");
        checkBool("5 > 4 and 5 > 4.0 and 5.0 > 4 and 5.0 > 4.0", "true");
        checkBool("5 >= 4 and 5 >= 4.0 and 5.0 >= 4 and 5.0 >= 4.0", "true");
        checkBool("4 == 4 and 4 == 4.0 and 4.0 == 4 and 4.0 == 4.0", "true");
        checkBool("5 <> 4 and 5 <> 4.0 and 5.0 <> 4 and 5.0 <> 4.0", "true");
    }

    @Test
    public void globalCVVDeclarations()
            throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        // TODO Inconsistent constant value type in class file Program
        // this is because of variables not initialized i think
        Class<?> clazz = genClass(
                """
                         const c_i_i int =       10;
                         const c_i_p int =       +10;
                         const c_i_n int =       -10;
                         const c_r_r real =      10.5;
                         const c_r_p real =      +10.5;
                         const c_r_n real =      -10.5;
                         const c_s string =      "nice";
                         const c_t bool =        true;
                         const c_f bool =        false;

                         const c_m_ii int =      7 * 2;      // 14
                         const c_m_riz real =    7.0 * 2;    // 14.0
                         const c_m_irz real =    7 * 2.0;    // 14.0
                         const c_m_ri real =     7.2 * 2;    // 14.4
                         const c_m_ir real =     7 * 2.7;    // 18.9
                         const c_m_rr real =     7.0 * 2.0;  // 14.0
                         const c_d_ii_i int =    8 / 2;      // 4
                         const c_d_ii int =     7 / 2;      // 3
                         const c_d_ri real =     7.0 / 2;    // 3.5
                         const c_d_ir real =     7 / 2.0;    // 3.5
                         const c_d_rr real =     7.0 / 2.0;  // 3.5

                         const c_hello string =  "hello" + " " + "world" + "!";

                         const c_mixed_i int =   7 / 2 + 4 * 2 - 2 * (-2); // 15
                         const c_mixed_r real =  7.0 / 2 + 4 * 2 - 2 * (-2); // 15.5
                         const c_hard int =     8 / (6 + 2 * -2) * 2; // 2

                         var v_i_i int =         10;
                         var v_i_p int =         +10;
                         var v_i_n int =         -10;
                         var v_r_r real =        10.5;
                         var v_r_p real =        +10.5;
                         var v_r_n real =        -10.5;
                         var v_s string =        "nice";
                         var v_t bool =          true;
                         var v_f bool =          false;

                         val v_hello string =    "hello" + " " + "world" + "!";

                         val v_mixed_i int =     7 / 2 + 4 * 2 - 2 * (-2); // 15
                         val v_mixed_r real =    7.0 / 2 + 4 * 2 - 2 * (-2); // 15.5
                         val v_hard int =       8 / (6 + 2 * -2) * 2; // 2

                         var r_i_i int =         10;
                         var r_i_p int =         +10;
                         var r_i_n int =         -10;
                         var r_r_r real =        10.5;
                         var r_r_p real =        +10.5;
                         var r_r_n real =        -10.5;
                         var r_s string =        "nice";
                         var r_t bool =          true;
                         var r_f bool =          false;

                         var r_hello string =    "hello" + " " + "world" + "!";

                         var r_mixed_i int =     7 / 2 + 4 * 2 - 2 * (-2); // 15
                         var r_mixed_r real =    7.0 / 2 + 4 * 2 - 2 * (-2); // 15.5
                         var r_hard int =       8 / (6 + 2 * -2) * 2; // 2

                        // expression and boolterm

                        val is_true bool =      true and false or true; // true = true and (false or true)
                        var is_false_l bool =   5 < 4 or 5 < 4.0 or 5.0 < 4 or 5.0 < 4.0;
                        var is_false_leq bool = 5 <= 4 or 5 <= 4.0 or 5.0 <= 4 or 5.0 <= 4.0;
                        var is_true_g bool =    5 > 4 and 5 > 4.0 and 5.0 > 4 and 5.0 > 4.0;
                        var is_true_geq bool =  5 >= 4 and 5 >= 4.0 and 5.0 >= 4 and 5.0 >= 4.0;
                        var is_true_eq bool =   4 == 4 and 4 == 4.0 and 4.0 == 4 and 4.0 == 4.0;
                        var is_true_neq bool =  5 <> 4 and 5 <> 4.0 and 5.0 <> 4 and 5.0 <> 4.0;

                        proc main() void {
                             writeInt(c_i_i); writeInt(c_i_p); writeInt(c_i_n); writeReal(c_r_r); writeReal(c_r_p); writeReal(c_r_n); write(c_s); writeBool(c_t); writeBool(c_f);
                             writeln("");
                             writeInt(c_m_ii); writeReal(c_m_riz); writeReal(c_m_irz); writeReal(c_m_ri); writeReal(c_m_ir); writeReal(c_m_rr); writeInt(c_d_ii_i); writeInt(c_d_ii); writeReal(c_d_ri); writeReal(c_d_ir); writeReal(c_d_rr);
                             writeln("");
                             writeln(c_hello);
                             writeInt(c_mixed_i); writeReal(c_mixed_r); writeInt(c_hard);
                             writeln("");
                             writeInt(v_i_i); writeInt(v_i_p); writeInt(v_i_n); writeReal(v_r_r); writeReal(v_r_p); writeReal(v_r_n); write(v_s); writeBool(v_t); writeBool(v_f);
                             writeln("");
                             writeln(v_hello);
                             writeInt(v_mixed_i); writeReal(v_mixed_r); writeInt(v_hard);
                             writeln("");
                             writeInt(r_i_i); writeInt(r_i_p); writeInt(r_i_n); writeReal(r_r_r); writeReal(r_r_p); writeReal(r_r_n); write(r_s); writeBool(r_t); writeBool(r_f);
                             writeln("");
                             writeln(r_hello);
                             writeInt(r_mixed_i); writeReal(r_mixed_r); writeInt(r_hard);
                             writeln("");
                             writeBool(is_true); writeBool(is_false_l); writeBool(is_false_leq); writeBool(is_true_g); writeBool(is_true_geq); writeBool(is_true_eq); writeBool(is_true_neq);
                        }
                        """);
    }

    @Test
    public void procedureDeclarations()
            throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        Class<?> clazz = genClass("""
                    proc sum(a int, b int) int { return a + b; }
                    proc sub(a int, b int) int { return a - b; }
                    proc mul(a int, b int) int { return a * b; }
                    proc div(a int, b int) int { return a / b; }
                    proc mod(a int, b int) int { return a % b; }

                    proc lt(a int, b int) bool { return a < b; }
                    proc gt(a int, b int) bool { return a > b; }
                    proc le(a int, b int) bool { return a <= b; }
                    proc ge(a int, b int) bool { return a >= b; }
                    proc eq(a int, b int) bool { return a == b; }
                    proc ne(a int, b int) bool { return a <> b; }

                    // with reals
                    proc r_sum(a int, b real) real { return a + b; }
                    proc r_sub(a int, b real) real { return a - b; }
                    proc r_mul(a int, b real) real { return a * b; }
                    proc r_div(a int, b real) real { return a / b; }

                    proc r_lt(a int, b real) bool { return a < b; }
                    proc r_gt(a int, b real) bool { return a > b; }
                    proc r_le(a int, b real) bool { return a <= b; }
                    proc r_ge(a int, b real) bool { return a >= b; }
                    proc r_eq(a int, b real) bool { return a == b; }
                    proc r_ne(a int, b real) bool { return a <> b; }
                """);

        checkMethod(clazz, "sum", 10 + 5, 10, 5);
        checkMethod(clazz, "sub", 10 - 5, 10, 5);
        checkMethod(clazz, "mul", 10 * 5, 10, 5);
        checkMethod(clazz, "div", 10 / 5, 10, 5);
        checkMethod(clazz, "mod", 10 % 5, 10, 5);

        checkMethod(clazz, "lt", 10 < 5, 10, 5);
        checkMethod(clazz, "gt", 10 > 5, 10, 5);
        checkMethod(clazz, "le", 10 <= 5, 10, 5);
        checkMethod(clazz, "ge", 10 >= 5, 10, 5);
        checkMethod(clazz, "eq", 10 == 5, 10, 5);
        checkMethod(clazz, "ne", 10 != 5, 10, 5);

        checkMethod(clazz, "r_sum", 10 + 5.0, 10, 5.0);
        checkMethod(clazz, "r_sub", 10 - 5.0, 10, 5.0);
        checkMethod(clazz, "r_mul", 10 * 5.0, 10, 5.0);
        checkMethod(clazz, "r_div", 10 / 5.0, 10, 5.0);

        checkMethod(clazz, "r_lt", 10 < 5.0, 10, 5.0);
        checkMethod(clazz, "r_gt", 10 > 5.0, 10, 5.0);
        checkMethod(clazz, "r_le", 10 <= 5.0, 10, 5.0);
        checkMethod(clazz, "r_ge", 10 >= 5.0, 10, 5.0);
        checkMethod(clazz, "r_eq", 10 == 5.0, 10, 5.0);
        checkMethod(clazz, "r_ne", 10 != 5.0, 10, 5.0);
    }

    @Test
    public void fibonacci() throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        Class<?> clazz = genClass("""
                    proc fib(n int) int {
                        if n <= 1 {
                            return n;
                        } else {
                            return fib(n - 1) + fib(n - 2);
                        }
                    }

                    proc main() void {
                        var i int = 0;
                        while i < 20 {
                            write(fib(i) + " ");
                            i = i + 1;
                        }
                        writeln("");
                    }
                """);

        run(clazz, "main", "0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181");
    }

    @Test
    public void fi() throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        Class<?> clazz = genClass("""
                    proc fi(a int) int {
                        if (a > 42) {
                            return 1;
                        }
                        return 0;
                    }

                    proc fiesle(a int) int {
                        if (a > 42) {
                            return 1;
                        } else {
                            return 0;
                        }
                    }
                """);

        checkMethod(clazz, "fi", 1, 69);
        checkMethod(clazz, "fi", 0, 7);
        checkMethod(clazz, "fi", 0, 42);

        checkMethod(clazz, "fiesle", 1, 69);
        checkMethod(clazz, "fiesle", 0, 7);
        checkMethod(clazz, "fiesle", 0, 42);
    }

    @Test
    public void elihw() throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        Class<?> clazz = genClass("""
                    proc elihw(a int) int {
                        var i int = 0;
                        while i < a {
                            i = i + 1;
                        }
                        return i;
                    }
                """);

        checkMethod(clazz, "elihw", 42, 42);
        checkMethod(clazz, "elihw", 0, 0);
    }

    //TODO there are some todos in this test
    @Test
    public void arrays() throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        Class<?> clazz = genClass("""
                    //TODO initialize them into the static
                    var a int[] = int[](5);
                    var b real[] = real[](3);
                    var c bool[] = bool[](2);
                    var d string[] = string[](9);

                    proc main() void {
                        var a1 int[] = int[](1);
                        var b2 real[] = real[](2);
                        var c3 bool[] = bool[](55);
                        var a4 string[] = string[](2);

                        var x int = a1[0];
                        var x1 real = b2[0];
                        var x2 bool = c3[0];
                        var x3 string = a4[0];

                        var x5 bool = c3[0+1 *5 + a[0]]; //TODO  problem when using a[0]

                        var i int = 2;
                        var x6 bool = c3[0+1 *5+i]; //TODO it doesn't appear the "i" it appears the final number (7)

                        // a1[0] = 1;
                        // a1[0] = 2+4-23;
                        // b2[1] = 3.1415;
                        // c3[33] = true;
                        // a4[0] = "Hello";
                    }

                    proc testing(a int[]) void {
                        var auxiliar int = a[0];
                    }
                """);

        callMethod(clazz, "main");
    }

    @Test
    public void records() throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        Class<?> clazz = genClass("""
                    record Person {
                        name string;
                        age int;
                    }

                    var g Person = Person("Global", 13);

                    proc main() void {
                        var p Person = Person("John", 42);
                        writeln(p.name + " is " + p.age + " years old.");
                        writeln(g.name + " is " + g.age + " years old.");
                    }
                """);

        run(clazz, "main", "John is 42 years old.\nGlobal is 13 years old.");
    }

    @Test
    public void test() throws ParseException, LexerException, SemanticException, CodeGeneratorException {
        Class<?> clazz = genClass("""
                    //TODO initialize them into the static
                    var a int[] = int[](5);
                    var b real[] = real[](3);
                    var c bool[] = bool[](2);
                    var d string[] = string[](9);
                    
                    proc main() void {
                        
                    }
                """);

        callMethod(clazz, "main");
    }
}
